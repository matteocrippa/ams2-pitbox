#!/usr/bin/env python3
"""ams2-pitbox

KISS entrypoint: run this file to install an Automobilista 2 mod archive.

Example:
  ./pitbox ~/Downloads/SomeMod.zip
"""

from __future__ import annotations

import argparse
import errno
import os
import re
import shutil
import subprocess
import sys
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional


@dataclass(frozen=True)
class SteamLibrary:
  root: Path

  @property
  def steamapps(self) -> Path:
    return self.root / "steamapps"

  @property
  def common(self) -> Path:
    return self.steamapps / "common"


def log(msg: str) -> None:
  print(f"[ams2-pitbox] {msg}")


def die(msg: str, code: int = 1) -> None:
  log(f"ERROR: {msg}")
  raise SystemExit(code)


def which(cmd: str) -> Optional[str]:
  return shutil.which(cmd)


def read_text_best_effort(path: Path) -> str:
  try:
    return path.read_text(encoding="utf-8", errors="replace")
  except Exception:
    return ""


def steam_default_roots() -> List[Path]:
  home = Path.home()
  return [
    home / ".local" / "share" / "Steam",
    home / ".steam" / "steam",
  ]


def parse_libraryfolders_vdf(vdf_path: Path) -> List[Path]:
  txt = read_text_best_effort(vdf_path)
  paths: List[Path] = []
  for m in re.finditer(r'"path"\s+"([^"]+)"', txt):
    raw = m.group(1).replace("\\\\", "/")
    paths.append(Path(raw).expanduser())
  return paths


def find_steam_libraries() -> List[SteamLibrary]:
  libs: List[Path] = []
  for root in steam_default_roots():
    vdf = root / "steamapps" / "libraryfolders.vdf"
    if vdf.is_file():
      libs.extend(parse_libraryfolders_vdf(vdf))
  libs.extend(steam_default_roots())

  uniq: List[Path] = []
  seen = set()
  for p in libs:
    try:
      rp = p.expanduser().resolve()
    except Exception:
      rp = p.expanduser()
    key = str(rp)
    if key in seen:
      continue
    seen.add(key)
    if (rp / "steamapps").is_dir():
      uniq.append(rp)
  return [SteamLibrary(root=p) for p in uniq]


def detect_ams2_dirs(libs: Iterable[SteamLibrary]) -> List[Path]:
  candidates: List[Path] = []
  for lib in libs:
    stable = lib.common / "Automobilista 2"
    beta = lib.common / "Automobilista 2 Beta"
    if stable.is_dir():
      candidates.append(stable)
    if beta.is_dir():
      candidates.append(beta)
  return candidates


def guess_label_for_path(p: Path) -> str:
  s = str(p)
  if "/run/media/" in s or "/media/" in s or "/mnt/" in s:
    return "SD / External"
  if str(Path.home()) in s:
    return "Internal (home)"
  return "Steam library"


def choose_from_list(prompt: str, options: List[Path]) -> Path:
  if not options:
    die("No options to choose from")
  if len(options) == 1:
    return options[0]

  log(prompt)
  for i, opt in enumerate(options, start=1):
    log(f"  {i}) {guess_label_for_path(opt)}: {opt}")

  while True:
    sel = input("Select a number: ").strip()
    if not sel.isdigit():
      log("Please enter a number.")
      continue
    idx = int(sel)
    if 1 <= idx <= len(options):
      return options[idx - 1]
    log("Out of range.")


def extract_archive(archive: Path, dest_dir: Path) -> None:
  suffix = archive.suffix.lower()

  if suffix == ".zip":
    import zipfile

    with zipfile.ZipFile(archive, "r") as zf:
      zf.extractall(dest_dir)
    return

  seven_zip = which("7z") or which("7zz")
  if not seven_zip:
    die(
      f"Archive '{archive.name}' requires 7zip (7z/7zz). "
      "Install it (Steam Deck / Debian/Ubuntu: 'sudo apt install p7zip-full'), "
      "or extract the archive manually and pass the extracted folder."
    )

  cmd = [seven_zip, "x", "-y", f"-o{str(dest_dir)}", str(archive)]
  log("Extracting…")
  proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
  if proc.returncode != 0:
    log(proc.stdout)
    die(f"7z failed to extract archive (exit {proc.returncode}).")


def _seven_zip_path() -> Optional[str]:
  return which("7z") or which("7zz")


def list_archive_members(archive: Path) -> List[str]:
  """List file members inside an archive without extracting it.

  For .zip uses the stdlib. For .7z/.rar uses 7z/7zz.
  Returns member paths as stored in the archive.
  """
  suffix = archive.suffix.lower()
  if suffix == ".zip":
    import zipfile

    with zipfile.ZipFile(archive, "r") as zf:
      return list(zf.namelist())

  seven_zip = _seven_zip_path()
  if not seven_zip:
    die(
      f"Archive '{archive.name}' requires 7zip (7z/7zz). "
      "Install it, or extract the archive manually and pass the extracted folder."
    )

  # -slt gives a stable, parseable format.
  cmd = [seven_zip, "l", "-slt", str(archive)]
  proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
  if proc.returncode != 0:
    log(proc.stdout)
    die(f"7z failed to list archive members (exit {proc.returncode}).")

  members: List[str] = []
  cur_path: Optional[str] = None
  cur_is_folder: Optional[bool] = None
  in_listing = False

  for raw in proc.stdout.splitlines():
    line = raw.strip("\r\n")
    # 7z -slt prints an initial properties block for the archive itself.
    # The actual file listing begins after a dashed separator.
    if line.startswith("----------"):
      in_listing = True
      cur_path = None
      cur_is_folder = None
      continue
    if not in_listing:
      continue
    if line.startswith("Path = "):
      cur_path = line[len("Path = ") :]
      cur_is_folder = None
      continue
    if line.startswith("Folder = "):
      v = line[len("Folder = ") :].strip().lower()
      cur_is_folder = v in {"+", "yes", "true"}
      continue
    # Record at block boundaries.
    if line == "" and cur_path is not None:
      if not cur_is_folder:
        members.append(cur_path)
      cur_path = None
      cur_is_folder = None

  # Flush last block (7z output doesn't always end with blank line).
  if cur_path is not None and not cur_is_folder:
    members.append(cur_path)

  return members


def archive_contains_overlay(members: Iterable[str]) -> bool:
  """Cheap check: does the archive appear to contain an AMS2 overlay directly?"""
  for m in members:
    mp = m.replace("\\", "/").lstrip("/")
    if mp == "Automobilista 2" or mp.startswith("Automobilista 2/"):
      return True
    if mp == "Vehicles" or mp.startswith("Vehicles/"):
      return True
    if mp == "UserData" or mp.startswith("UserData/"):
      return True
  return False


def archive_nested_members(members: Iterable[str]) -> List[str]:
  nested: List[str] = []
  for m in members:
    mp = m.replace("\\", "/")
    # Skip obvious directories.
    if mp.endswith("/"):
      continue
    lower = mp.lower()
    if lower.endswith((".zip", ".7z", ".rar")):
      nested.append(m)
  nested.sort(key=lambda s: s.lower())
  return nested


def extract_member_to_file(archive: Path, member: str, out_file: Path) -> None:
  """Extract a single member from an archive to a file on disk.

  This enables processing 'container packs' (archive of many archives) without
  fully extracting the outer archive.
  """
  out_file.parent.mkdir(parents=True, exist_ok=True)
  suffix = archive.suffix.lower()
  if suffix == ".zip":
    import zipfile

    with zipfile.ZipFile(archive, "r") as zf:
      with zf.open(member, "r") as src, out_file.open("wb") as dst:
        shutil.copyfileobj(src, dst, length=1024 * 1024)
    return

  seven_zip = _seven_zip_path()
  if not seven_zip:
    die(
      f"Archive '{archive.name}' requires 7zip (7z/7zz). "
      "Install it, or extract the archive manually and pass the extracted folder."
    )

  # -so streams file contents to stdout; keep stdout clean and avoid progress noise.
  cmd = [seven_zip, "x", "-y", "-bd", "-so", str(archive), member]
  with out_file.open("wb") as fh:
    proc = subprocess.run(cmd, stdout=fh, stderr=subprocess.PIPE)
  if proc.returncode != 0:
    err = proc.stderr.decode("utf-8", errors="replace") if proc.stderr else ""
    if err:
      log(err)
    die(f"7z failed to extract member '{member}' (exit {proc.returncode}).")


def is_writable_dir(p: Path) -> bool:
  try:
    p.mkdir(parents=True, exist_ok=True)
    probe = p / f".ams2_pitbox_write_test_{os.getpid()}"
    probe.write_text("ok", encoding="utf-8")
    probe.unlink(missing_ok=True)
    return True
  except Exception:
    return False


def is_archive_file(path: Path) -> bool:
  if not path.is_file():
    return False
  return path.suffix.lower() in {".zip", ".7z", ".rar"}


def find_archives(extracted_dir: Path) -> List[Path]:
  archives: List[Path] = []
  for root, _dirs, files in os.walk(extracted_dir):
    r = Path(root)
    for f in files:
      p = r / f
      if is_archive_file(p):
        archives.append(p)
  # Deterministic order.
  archives.sort(key=lambda p: str(p).lower())
  return archives


def install_from_extracted_dir(
  source_dir: Path,
  *,
  game_dir: Path,
  dry_run: bool,
  work_dir: Path,
  keep_work: bool,
  max_depth: int,
  _depth: int = 0,
) -> int:
  """Install a mod from an extracted folder.

  Handles direct overlays and folders that contain nested archives.
  """
  direct = try_find_overlay_root(source_dir)
  if direct is not None:
    log(f"Mod root: {direct}")
    install_overlay(direct, game_dir, dry_run)
    return 1

  if _depth >= max_depth:
    return 0

  archives = find_archives(source_dir)
  if not archives:
    return 0

  installed = 0
  for arc in archives:
    installed += install_from_archive(
      arc,
      game_dir=game_dir,
      dry_run=dry_run,
      work_dir=work_dir,
      keep_work=keep_work,
      max_depth=max_depth,
      _depth=_depth + 1,
    )

  return installed


def install_from_archive(
  archive: Path,
  *,
  game_dir: Path,
  dry_run: bool,
  work_dir: Path,
  keep_work: bool,
  max_depth: int,
  _depth: int = 0,
) -> int:
  """Install a mod from an archive.

  Smart behavior:
  - If archive contains a direct overlay, extract to a temp folder and install.
  - If archive looks like a container pack (many nested archives), extract each
    nested archive member one-by-one to disk, install it, then clean up.
  """
  if _depth > max_depth:
    return 0

  try:
    members = list_archive_members(archive)
  except OSError as e:
    # Listing itself rarely hits ENOSPC, but keep messaging consistent.
    if getattr(e, "errno", None) == errno.ENOSPC:
      die(
        "No space left on device while reading archive metadata. "
        "Try using --work-dir on a larger disk (e.g. SD card) or free space."
      )
    raise

  # Direct overlay: use existing extraction + robust overlay detection.
  if archive_contains_overlay(members):
    if keep_work:
      tmpdir = Path(tempfile.mkdtemp(prefix="ams2_pitbox_", dir=str(work_dir)))
      log(f"Keeping work folder for debugging: {tmpdir}")
      try:
        extract_archive(archive, tmpdir)
        installed = install_from_extracted_dir(
          tmpdir,
          game_dir=game_dir,
          dry_run=dry_run,
          work_dir=work_dir,
          keep_work=keep_work,
          max_depth=max_depth,
          _depth=_depth,
        )
      except OSError as e:
        if getattr(e, "errno", None) == errno.ENOSPC:
          die(
            "No space left on device while extracting the archive. "
            f"Try --work-dir on a larger disk. Current work dir: {work_dir}"
          )
        raise
      return installed

    with tempfile.TemporaryDirectory(prefix="ams2_pitbox_", dir=str(work_dir)) as tmp:
      tmpdir = Path(tmp)
      try:
        extract_archive(archive, tmpdir)
      except OSError as e:
        if getattr(e, "errno", None) == errno.ENOSPC:
          die(
            "No space left on device while extracting the archive. "
            f"Try --work-dir on a larger disk. Current work dir: {work_dir}"
          )
        raise

      return install_from_extracted_dir(
        tmpdir,
        game_dir=game_dir,
        dry_run=dry_run,
        work_dir=work_dir,
        keep_work=keep_work,
        max_depth=max_depth,
        _depth=_depth,
      )

  nested = archive_nested_members(members)
  if nested and _depth < max_depth:
    log(f"Detected container pack: {archive.name} ({len(nested)} nested archives)")

    # Process one nested archive at a time to keep disk usage bounded.
    installed = 0
    for i, member in enumerate(nested, start=1):
      base = Path(member.replace("\\", "/")).name
      log(f"[{i}/{len(nested)}] Processing nested archive: {base}")

      tmp_parent = Path(
        tempfile.mkdtemp(prefix="ams2_pitbox_child_", dir=str(work_dir))
      )
      try:
        child_archive = tmp_parent / base
        try:
          extract_member_to_file(archive, member, child_archive)
        except OSError as e:
          if getattr(e, "errno", None) == errno.ENOSPC:
            die(
              "No space left on device while extracting a nested archive from the container. "
              f"Try --work-dir on a larger disk. Current work dir: {work_dir}"
            )
          raise

        installed += install_from_archive(
          child_archive,
          game_dir=game_dir,
          dry_run=dry_run,
          work_dir=work_dir,
          keep_work=keep_work,
          max_depth=max_depth,
          _depth=_depth + 1,
        )
      finally:
        if keep_work:
          log(f"Keeping work folder for debugging: {tmp_parent}")
        else:
          shutil.rmtree(tmp_parent, ignore_errors=True)
    return installed

  # Fallback: unknown layout. Extract fully and try existing heuristics.
  if keep_work:
    tmpdir = Path(tempfile.mkdtemp(prefix="ams2_pitbox_", dir=str(work_dir)))
    log(f"Keeping work folder for debugging: {tmpdir}")
    try:
      extract_archive(archive, tmpdir)
    except OSError as e:
      if getattr(e, "errno", None) == errno.ENOSPC:
        die(
          "No space left on device while extracting the archive. "
          f"Try --work-dir on a larger disk. Current work dir: {work_dir}"
        )
      raise
    return install_from_extracted_dir(
      tmpdir,
      game_dir=game_dir,
      dry_run=dry_run,
      work_dir=work_dir,
      keep_work=keep_work,
      max_depth=max_depth,
      _depth=_depth,
    )

  with tempfile.TemporaryDirectory(prefix="ams2_pitbox_", dir=str(work_dir)) as tmp:
    tmpdir = Path(tmp)
    try:
      extract_archive(archive, tmpdir)
    except OSError as e:
      if getattr(e, "errno", None) == errno.ENOSPC:
        die(
          "No space left on device while extracting the archive. "
          f"Try --work-dir on a larger disk. Current work dir: {work_dir}"
        )
      raise
    return install_from_extracted_dir(
      tmpdir,
      game_dir=game_dir,
      dry_run=dry_run,
      work_dir=work_dir,
      keep_work=keep_work,
      max_depth=max_depth,
      _depth=_depth,
    )


def try_find_overlay_root(extracted_dir: Path) -> Optional[Path]:
  try:
    return find_overlay_root(extracted_dir)
  except SystemExit:
    return None


def collect_overlay_roots(source_dir: Path, *, max_depth: int = 2, _depth: int = 0) -> List[Path]:
  """Return one or more overlay roots contained in a directory.

  Supports "container" archives that unpack into multiple mod archives.
  """
  direct = try_find_overlay_root(source_dir)
  if direct is not None:
    return [direct]

  if _depth >= max_depth:
    return []

  archives = find_archives(source_dir)
  if not archives:
    return []

  overlays: List[Path] = []
  container = source_dir / "_ams2_pitbox_container"
  container.mkdir(parents=True, exist_ok=True)

  for i, arc in enumerate(archives, start=1):
    child_dir = container / f"child_{i:03d}"
    if child_dir.exists():
      shutil.rmtree(child_dir)
    child_dir.mkdir(parents=True, exist_ok=True)

    log(f"Extracting nested archive: {arc.name}")
    extract_archive(arc, child_dir)
    overlays.extend(collect_overlay_roots(child_dir, max_depth=max_depth, _depth=_depth + 1))

  # If a container has many nested archives, there may be duplicates (rare).
  uniq: List[Path] = []
  seen = set()
  for p in overlays:
    key = str(p.resolve()) if p.exists() else str(p)
    if key in seen:
      continue
    seen.add(key)
    uniq.append(p)
  return uniq


def find_overlay_root(extracted_dir: Path) -> Path:
  # 1) Most common: an "Automobilista 2" folder.
  for root, dirs, _files in os.walk(extracted_dir):
    if "Automobilista 2" in dirs:
      return Path(root) / "Automobilista 2"

  # 2) Fallback: direct overlay roots.
  for root, dirs, _files in os.walk(extracted_dir):
    dset = set(dirs)
    if "UserData" in dset or "Vehicles" in dset:
      return Path(root)

  # 3) Fallback: "flat" skin packs.
  # Some archives contain only a single Overrides/<vehicle>/ folder with XML + DDS,
  # without the full Automobilista 2/Vehicles/... hierarchy. Detect and wrap.
  skin = find_skin_pack_root(extracted_dir)
  if skin is not None:
    log("Detected a skin-only archive; building an overlay structure…")
    return build_overlay_from_skin_pack(extracted_dir, skin)

  die(
    "Could not find an AMS2 overlay in the extracted archive. "
    "Expected an 'Automobilista 2/' folder (or at least 'UserData/' / 'Vehicles/')."
  )


def looks_like_user_overrides_xml(path: Path) -> bool:
  try:
    # Keep it cheap: only scan the beginning.
    head = path.read_text(encoding="utf-8", errors="replace")[:4096].lower()
  except Exception:
    return False
  return "<user_overrides" in head


def find_skin_pack_root(extracted_dir: Path) -> Optional[Path]:
  """Find a directory that looks like an AMS2 livery override folder.

  Heuristic: a folder containing at least one override XML (USER_OVERRIDES)
  and at least one .dds somewhere below it.
  """
  candidates: List[Path] = []

  for root, _dirs, files in os.walk(extracted_dir):
    r = Path(root)
    xmls = [r / f for f in files if f.lower().endswith(".xml")]
    if not xmls:
      continue
    if not any(looks_like_user_overrides_xml(x) for x in xmls):
      continue

    # Check for at least one .dds in this folder or subfolders.
    has_dds = False
    for _r2, _d2, f2 in os.walk(r):
      if any(fn.lower().endswith(".dds") for fn in f2):
        has_dds = True
        break
    if not has_dds:
      continue

    candidates.append(r)

  if not candidates:
    return None

  # Prefer candidates that are already under an 'Overrides' folder.
  def score(p: Path) -> int:
    parts = [x.lower() for x in p.parts]
    return 10 if "overrides" in parts else 0

  candidates.sort(key=score, reverse=True)

  # If there are multiple plausible roots, ask the user.
  if len(candidates) > 1:
    chosen = choose_from_list(
      "Multiple skin folders found in archive. Which one should be installed?",
      candidates,
    )
    return chosen

  return candidates[0]


def infer_vehicle_override_folder_name(skin_root: Path) -> str:
  # Common case: .../Overrides/<vehicle_name>
  parts = list(skin_root.parts)
  lowered = [p.lower() for p in parts]
  if "overrides" in lowered:
    i = lowered.index("overrides")
    if i + 1 < len(parts):
      return parts[i + 1]
  return skin_root.name


def build_overlay_from_skin_pack(extracted_dir: Path, skin_root: Path) -> Path:
  """Wrap a flat skin folder into a valid overlay root.

  Creates:
    <extracted_dir>/_ams2_pitbox_overlay/\
      Vehicles/Textures/CustomLiveries/Overrides/<vehicle>/...

  Then copies skin_root contents into that target.
  """
  overlay_base = extracted_dir / "_ams2_pitbox_overlay"
  vehicle = infer_vehicle_override_folder_name(skin_root)
  target = (
    overlay_base
    / "Vehicles"
    / "Textures"
    / "CustomLiveries"
    / "Overrides"
    / vehicle
  )

  if overlay_base.exists():
    # Shouldn't happen in our temp dir, but keep it deterministic.
    shutil.rmtree(overlay_base)

  target.parent.mkdir(parents=True, exist_ok=True)
  shutil.copytree(skin_root, target, dirs_exist_ok=True)
  log(f"Skin overlay target: {target}")
  return overlay_base


def install_overlay(overlay_root: Path, game_dir: Path, dry_run: bool) -> None:
  """Install overlay into the game dir using only the Python stdlib."""

  def copy_tree(src: Path, dst: Path) -> None:
    if not src.exists():
      return
    if dry_run:
      log(f"(dry-run) Would copy: {src} -> {dst}")
      return
    dst.mkdir(parents=True, exist_ok=True)
    shutil.copytree(src, dst, dirs_exist_ok=True)

  copy_tree(overlay_root / "UserData", game_dir / "UserData")
  copy_tree(overlay_root / "Vehicles", game_dir / "Vehicles")


def main(argv: Optional[List[str]] = None) -> int:
  ap = argparse.ArgumentParser(
    description="AMS2 PitBox — install an Automobilista 2 mod archive on Linux/Steam Deck"
  )
  ap.add_argument(
    "source",
    type=Path,
    help=(
      "Path to mod archive (.zip, .7z, .rar, ...) OR a folder you already extracted manually"
    ),
  )
  ap.add_argument(
    "--game-dir",
    type=Path,
    default=None,
    help="Path to 'Automobilista 2' folder (only if auto-detection fails)",
  )
  ap.add_argument("--dry-run", action="store_true", help="Print actions without writing files")
  ap.add_argument(
    "--work-dir",
    type=Path,
    default=None,
    help=(
      "Where to extract temporary files. Useful for large container packs. "
      "Default: next to the source archive/folder (if writable), else /tmp/system temp."
    ),
  )
  ap.add_argument(
    "--keep-work",
    action="store_true",
    help="Do not delete temporary extraction folders (debugging / inspection).",
  )
  ap.add_argument(
    "--max-depth",
    type=int,
    default=2,
    help="Maximum recursion depth for nested archives (default: 2)",
  )

  args = ap.parse_args(argv)

  source = args.source.expanduser()
  if not source.exists():
    die(f"Source not found: {source}")

  # Determine where to place temporary files.
  if args.work_dir is not None:
    work_dir = args.work_dir.expanduser()
    if not work_dir.exists():
      die(f"--work-dir does not exist: {work_dir}")
    if not work_dir.is_dir():
      die(f"--work-dir is not a directory: {work_dir}")
  else:
    # KISS default: extract next to the archive/folder when possible.
    # This avoids small /tmp partitions and keeps everything on the same disk.
    preferred = source if source.is_dir() else source.parent
    if is_writable_dir(preferred):
      work_dir = preferred
    else:
      work_dir = Path("/tmp") if Path("/tmp").is_dir() else Path(tempfile.gettempdir())

  if args.game_dir is not None:
    game_dir = args.game_dir.expanduser()
    if not game_dir.is_dir():
      die(f"--game-dir does not exist: {game_dir}")
  else:
    libs = find_steam_libraries()
    candidates = detect_ams2_dirs(libs)
    if not candidates:
      die(
        "Could not auto-detect Automobilista 2 in your Steam libraries. "
        "Use --game-dir '/path/to/steamapps/common/Automobilista 2'"
      )
    game_dir = choose_from_list("Where is Automobilista 2 installed?", candidates)

  if source.is_dir():
    log(f"Installing to: {game_dir}")
    installed = install_from_extracted_dir(
      source,
      game_dir=game_dir,
      dry_run=args.dry_run,
      work_dir=work_dir,
      keep_work=args.keep_work,
      max_depth=max(0, args.max_depth),
    )
    if installed == 0:
      die(
        "Could not find an AMS2 overlay (or nested mod archives) in the provided folder. "
        "Expected an 'Automobilista 2/' folder (or at least 'UserData/' / 'Vehicles/'), "
        "or a folder containing mod archives (.zip/.7z/.rar)."
      )
  else:
    log(f"Installing to: {game_dir}")
    installed = install_from_archive(
      source,
      game_dir=game_dir,
      dry_run=args.dry_run,
      work_dir=work_dir,
      keep_work=args.keep_work,
      max_depth=max(0, args.max_depth),
    )
    if installed == 0:
      die(
        "Could not find an AMS2 overlay in the archive (or nested mod archives inside it). "
        "Expected an 'Automobilista 2/' folder (or at least 'UserData/' / 'Vehicles/'), "
        "or nested mod archives (.zip/.7z/.rar)."
      )

  log("Done.")
  return 0


if __name__ == "__main__":
  raise SystemExit(main())
